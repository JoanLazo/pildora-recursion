import { Head, Appear } from 'mdx-deck';
import MathJax from 'react-mathjax';
import Code from 'mdx-code';
import { Split } from 'mdx-deck/layouts'
// import { Notes } from 'mdx-deck'

import LeftLayout from './src/layout/LeftLayout';
// import MD from './src/lib/Markdown';

export { default as theme } from './theme'

<Head>
  <title>Recursión</title>
</Head>

import noCode from './src/lib/no-code';

# Recursión

<small>21 de febrero de 2019</small>

---

export default LeftLayout;

## Ejemplo 1: Factorial

<MathJax.Provider>
  <MathJax.Node inline formula={'n! = n × (n - 1) × (n - 2) × ... × 3 × 2 × 1'}/>
</MathJax.Provider>

```notes
En la matemática, la función factorial de un número entero positivo ***n***
se define como el producto (multiplicación) de todos los números enteros
positivos menores o iguales que ***n***, y se denota de la siguiente
manera: ***n!***
```
---

export default LeftLayout;

## Factorial (ejemplo)

<MathJax.Provider>
  <div><MathJax.Node inline formula={'5! = 5 × 4 × 3 × 2 × 1 = 120'}/></div>
  <Appear>
    <div><MathJax.Node inline formula={'5! = 5 × (4 × 3 × 2 × 1)'}/></div>
    <div><MathJax.Node inline formula={'5! = 5 × 4!'}/></div>
    <div><MathJax.Node inline formula={'5! = 5 × (4 × 3!)'}/></div>
    <div><MathJax.Node inline formula={'5! = 5 × (4 × (3 × 2!))'}/></div>
    <div><MathJax.Node inline formula={'5! = 5 × (4 × (3 × (2 × 1!)))'}/></div>
    <div><MathJax.Node inline formula={'5! = 5 × (4 × (3 × (2 × 1)))'}/></div>
    <div><MathJax.Node inline formula={'5! = 5 × 4 × 3 × 2 × 1 = 120'}/></div>
    <br/>
    <MathJax.Node inline formula={'1! = 1'}/>
    <div>
      <MathJax.Node inline formula={'n! = n * (n-1)!'}/>{'   '}
      para <MathJax.Node inline formula={'n > 1'}/>
    </div>
  </Appear>
</MathJax.Provider>

---

## Factorial (ejemplo)

import FactorialIterCode from './src/slides/FactorialIterCode';

export default () => <FactorialIterCode noCode={noCode} />;

```notes
Esta implementación poco tiene que ver
con la definición matemática del problema.
```

---

export default LeftLayout;

## Factorial

<MathJax.Provider>
  <MathJax.Node inline formula={'1! = 1'}/>
  <div>
    <MathJax.Node inline formula={'n! = n * (n-1)!'}/>{'   '}
    para <MathJax.Node inline formula={'n > 1'}/>
  </div>
</MathJax.Provider>

---

import FactorialCode from './src/slides/FactorialCode';

export default () => <FactorialCode noCode={noCode} />;

```notes
Mas elegante, no? Ahora la implementación de `factorial(n)`,
está expresada en función de `factorial(n-1)`.
```

---

import FactoriaCodelExplanation from './src/slides/FactorialCodeExplanation';

export default FactoriaCodelExplanation;

```notes
Y esa es la definición de una función recursiva:
*una función que se llama a sí misma*.

Y en general podemos hablar de **recursión** cómo un método para resolver
problemas, donde la solución global depende de la solución de instancias
más pequeñas del mismo problema.
```

---

import SinCasoBase from './src/slides/SinCasoBase';

export default () => <SinCasoBase noCode={noCode} />;

```notes
Algo muy importante de recordar:
> Toda función recursiva cuenta con un caso base, que es un paso donde
> la función retorna un resultado trivial, sin incurrir en recursión.

Ten en cuenta que si tus funciones recursivas no cuentan con un caso base,
no terminarían nunca de ejecutarse... en realidad terminan de ejecutarse
cuando agotan los recursos asignados.
```

---

## Ejercicio: Número de Fibonacci

<MathJax.Provider>
  <Appear>
    <div>
      <div><MathJax.Node inline formula={'Fib(0) = 0'}/></div>
      <div><MathJax.Node inline formula={'Fib(1) = 1'}/></div>
      y
      <div>
        <MathJax.Node inline formula={'Fib(n) = Fib(n-1) + Fib(n-2)'}/>,
        para <MathJax.Node inline formula={'n > 1'}/>
      </div>
    </div>
  </Appear>
</MathJax.Provider>

---

### Ejercicio: Número de Fibonacci

De esta manera

<MathJax.Provider>
  <div><MathJax.Node inline formula={'Fib(0) = 0'}/></div>
  <div><MathJax.Node inline formula={'Fib(1) = 1'}/></div>
  <div><MathJax.Node inline formula={'Fib(2) = 1'}/></div>
  <div><MathJax.Node inline formula={'Fib(3) = 2'}/></div>
  <div><MathJax.Node inline formula={'Fib(4) = 3'}/></div>
  <div><MathJax.Node inline formula={'Fib(5) = 5'}/></div>
  <div><MathJax.Node inline formula={'Fib(6) = 8'}/></div>
  <div><MathJax.Node inline formula={'Fib(7) = 13'}/></div>
</MathJax.Provider>

---

export default Code;

```javascript Ejercicio: Número de Fibonacci
function fib(n) {
  // escribe aquí tu codigo
}

console.assert(fib(0) === 0)
console.assert(fib(1) === 1)
console.assert(fib(2) === 1)
console.assert(fib(3) === 2)
console.assert(fib(4) === 3)
console.assert(fib(5) === 5)
console.assert(fib(6) === 8)
console.assert(fib(7) === 13)
```

---

import CirculosBase from './src/slides/Circulos/base';

export default CirculosBase;

---

import CirculosDos from './src/slides/Circulos/dos';

export default CirculosDos;

---

import CirculosCodeExplanation from './src/slides/CirculosCodeExplanation';

export default CirculosCodeExplanation;

---

import CirculosCuatroCodeExplanation from './src/slides/CirculosCodeExplanation/Cuatro';

export default CirculosCuatroCodeExplanation;

---

import CirculosCuatro from './src/slides/Circulos/cuatro';

export default CirculosCuatro;

---

## Estructuras de datos recursivas

<Appear>
  <h3>Ejemplo: Árboles (DOM)</h3>
</Appear>

```notes
Así como existen las funciones recursivas, también existen los **tipos de datos recursivos**.

Estos se caracterizan por estar compuestos por instancias mas pequeñas de la misma estructura.

Al tener esta caracteristica muchas de las operaciones que se pueden realizar sobre ellos, son a su vez recursivas.
```

---

export default Split

import WalkTheDomDom from './src/slides/WalkTheDom/Dom';
import WalkTheDomDomCode from './src/slides/WalkTheDom/DomCode';

<WalkTheDomDom />

<WalkTheDomDomCode />

---

import WalkTheDomCode from './src/slides/WalkTheDom/Code';

export default () => <WalkTheDomCode noCode={noCode} />;

---

export default Split

import WalkTheDomIFrame from './src/slides/WalkTheDom/IFrame';
import WalkTheDomCodeHighlight from './src/slides/WalkTheDom/CodeHighlight';

<WalkTheDomIFrame />

<WalkTheDomCodeHighlight />

---

import WalkTheDomCodeIter from './src/slides/WalkTheDom/CodeIter';

export default WalkTheDomCodeIter;

```notes
Aqui es importante que nos detengamos un segundo a analizar esta situacion
Cuando nos encontramos con un tipo de datos recursivo, es muy importante
que saquemos provecho de esa situacion, utilizando funciones recursivas para
recorrerlo y manipularlo.

En caso contrario, yendo contra la naturaleza del tipo de dato e intentando,
de manipularlo de manera iterativa, terminamos creando funciones muy dificiles
de comprender e implementar y de bajisima legibilidad.
```
---

# Conclusión

<https://github.com/merunga/pildora-recursion>

<https://merunga.github.io/pildora-recursion>

<https://youtu.be/lPPgY3HLlhQ>

```notes
Hemos podido ver a través de tres ejemplos la magia y la elegancia de la recursión

- Primero a traves de funciones recursivas que emulan en su implementación, a su definición formal

- Hemos visto de manera gráfica paso a paso la ejecución de un funcion recursiva

- Y finalmente hemos hablado de las estructuras de datos recursivas, y como
podemos usar la recursion para recorrerlas

